provisioner: aws
name: app-runner
version: 1
revision: 1
displayName: "App runner deployment"
description: "AWS App Runner Deployment template"
target: "deployment-template"
keywords: ["bash", "linux"]
author: "CloudCover"
meta:
  inputArtifactType:
    - ContainerImage
inputs:
  type: object
  properties:
    region:
      title: Region name
      description: region name for cluster
      type: string
    app_env:
      title: Application Environment
      description: Application Related Envs
      type: object
      default: {}
    repository:
      title: Container Repository
      description: Enter Full container url without tag
      type: string
      default: ""
    tag:
      title: Container tag
      description: Tagged container will deploy
      type: string
      default: latest
    ecr_role:
      title: ECR IAM Role
      description: Role to pull image from private ECR
      type: string
      default: ""
    instance_role:
      title: Instance IAM Role
      description: Role to be used by app runnner to interact with other AWS services
      type: string
      default: ""
    memory:
      title: Memory
      description: Memory to be consumed by app runner
      type: string
      default: "2 GB"
    cpu:
      title: CPU
      description: CPU to be consumed by app runner
      type: string
      default: "1 vCPU"
    vpc_connector_arn:
      title: VPC Connector ARN
      description: ARN for a connector to a specific VPC
      type: string
      default: ""
    is_public:
      title: Is Public
      description: Should this service be exposed to public network
      type: boolean
      default: true
    port:
      title: Container port
      type: integer
      maximum: 65535
    applicationName:
      title: Application name
      description: This is vanguard application name
      type: string
      default: latest
    environment:
      title: Environment Name
      description: This is vanguard environment name
      type: string
      default: latest
    project:
      title: Project Name
      description: This is a vanguard project name
      type: string
      default: latest
    job_type:
      title: Job Type
      description: This is to deploy or undeploy application
      type: string
      default: deploy
  required: ["region", "port"]
  internal:
    - app_env
    - repository
    - tag
    - applicationName
    - environment
    - project
    - job_type
template: |
  ########################################################################################################################################################
  # The module creates json config file for source configuration and instance configuration                                                              #
  # The module recieves a formatted list of pipeline env in {{ pipeline_env_file }},                                                                     #
  # So we don't have to worry about character escaping in this module.                                                                                   #
  ########################################################################################################################################################
  {% set workspace = '$CODEBUILD_SRC_DIR' %}   {# has to be a persistent volume #}
  {% set pipeline_env_file = workspace|add:'/.env' %}
  {% set pipeline_secret_file = workspace|add:'/.secret.env' %}  

  version: 0.2
  phases:
    install:
      commands:
        - aws configure set region {{region}}
    build:
      commands:
        {% if job_type == 'deploy' %}
        - |
          c=1; #Counter to check if its the last element in file
          length=$(cat {{pipeline_env_file}} | wc -l); #Finds out the number of elements to put in json
          echo "{" >> env.json; #start of the json file
          cat {{pipeline_env_file}} | while IFS= read -r line; do
            value=${line#*=}
            name=${line%%=*}
            if [ $c -ge $length ] #Check to add or remove trailing comma while writing JSON
            then
                printf '"%s":%s\n' "$name" "$value" >> env.json
                break;
            else
                printf '"%s":%s,\n' "$name" "$value" >> env.json
            fi
          c=$((c+1)) #Incrementing the counter
          done;
          echo "}" >> env.json;

          #Delete all secrets
          secret_list=$(aws secretsmanager list-secrets --query 'SecretList[?Description && starts_with(Description, `{{applicationName}}-{{environment}}-`) == `true`].[ARN]' --output text)
          # Delete each secret in the list
          for secret_arn in $secret_list
          do
            aws secretsmanager delete-secret --secret-id $secret_arn
          done
          
          sc=1; #Rest Counter to check if its the last element in file
          sl=$(cat {{pipeline_secret_file}} | wc -l);
          echo "{" >> env_secrets.json; #start of the json file
          cat {{pipeline_secret_file}} | while IFS= read -r line; do
            value=${line#*=}
            name=${line%%=*}
            arn=$(aws secretsmanager create-secret --name "cp-$(date +%s)-$RANDOM" --description "{{applicationName}}-{{environment}}-$name" --secret-string $value --query 'Service.ServiceUrl' --query ARN --output text)
            if [ $sc -ge $sl ] #Check to add or remove trailing comma while writing JSON
            then
                printf '"%s":"%s"\n' "$name" "$arn" >> env_secrets.json
                break;
            else
                printf '"%s":"%s",\n' "$name" "$arn" >> env_secrets.json
            fi
          sc=$((sc+1)) #Incrementing the counter
          done;
          echo "}" >> env_secrets.json;
          secretsJSON=$(cat env_secrets.json);
          envJSON=$(cat env.json);
          JSON_FMT='{
              "ImageRepository": {
                  "ImageIdentifier": "{{repository}}:{{tag}}",
                  "ImageConfiguration": {
                      "RuntimeEnvironmentVariables": %s,
                      "RuntimeEnvironmentSecrets": %s,
                      "Port": "{{port}}"
                  },
                  "ImageRepositoryType": {% if repository|slice:":7" == 'public.' %}"ECR_PUBLIC"{% else %}"ECR"{% endif %}
              },
              "AutoDeploymentsEnabled": false {% if repository|slice:":7" != 'public.' %},
              "AuthenticationConfiguration": {
                "AccessRoleArn": "{{ecr_role}}"
              }{% else %}{% endif %}
          }';
          # Replaces envs and secrets
          printf "$JSON_FMT" "$envJSON" "$secretsJSON">> app.json
        - |
          echo '{
            "Cpu": "{{cpu}}",
            "Memory": "{{memory}}"{% if instance_role != '' %},
            "InstanceRoleArn": "{{instance_role}}"{% else %}{% endif %}
          }' >> instance.json
        - |
          echo '{
            "EgressConfiguration": {
            {% if vpc_connector_arn != '' %}
                "EgressType": "VPC",
                "VpcConnectorArn": "{{vpc_connector_arn}}"
            {% else %}
                "EgressType": "DEFAULT"
            {% endif %}
            },
            "IngressConfiguration": {
            {% if is_public %}
                "IsPubliclyAccessible": true
            {% else %}
                "IsPubliclyAccessible": false
            {% endif %}
            }
          }' >> network.json
          sa=$(aws apprunner list-services --query 'ServiceSummaryList[?ServiceName==`{{applicationName}}-{{environment}}`].ServiceArn' --output text)
          if [ -z "$sa" ]; then
              serviceUrl=$(aws apprunner create-service --service-name  {{applicationName}}-{{environment}} --source-configuration file://app.json --instance-configuration file://instance.json --network-configuration file://network.json --query 'Service.ServiceUrl')
          else
              serviceUrl=$(aws apprunner update-service --service-arn $sa --source-configuration file://app.json --instance-configuration file://instance.json --network-configuration file://network.json --query 'Service.ServiceUrl')
          fi
    post_build:
      commands:
        - echo "###pipeline-summary-start###" >> summary.txt 2>&1;
        - echo "Service URL=https://"$serviceUrl | tr -d '"' >> summary.txt;
        - echo "###pipeline-summary-end###" >> summary.txt 2>&1;
        - cat summary.txt
      {% else %}
        - aws apprunner list-services --query 'ServiceSummaryList[?ServiceName==`{{applicationName}}-{{environment}}`].ServiceArn' --output text |  xargs -I{} aws apprunner delete-service --service-arn {}
      {% endif %}
